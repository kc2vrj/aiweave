<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .file-actions {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 1rem;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            display: none;
            justify-content: center;
            gap: 1rem;
            z-index: 1000;
        }
        
        .file-actions.visible {
            display: flex;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            border-bottom: 1px solid #eee;
            gap: 0.5rem;
        }
        
        .file-item:hover {
            background-color: #f5f5f5;
        }
        
        .file-item.selected {
            background-color: #e3f2fd;
        }
        
        .file-list {
            margin-bottom: 100px;
        }
        
        #output {
            height: 200px;
            overflow-y: auto;
        }
        
        .viewer-section {
            margin-top: 2rem;
            margin-bottom: 6rem;
        }
        
        .viewer-content {
            min-height: 500px;
            max-height: 800px;
            overflow-y: auto;
            background: white;
            padding: 2rem;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }
        
        /* Markdown content styles */
        .prose {
            font-size: 1rem;
            line-height: 1.75;
        }
        .prose h1 {
            font-size: 2em;
            margin-top: 1em;
            margin-bottom: 0.5em;
            font-weight: bold;
        }
        .prose h2 {
            font-size: 1.5em;
            margin-top: 1em;
            margin-bottom: 0.5em;
            font-weight: bold;
        }
        .prose p {
            margin-top: 1em;
            margin-bottom: 1em;
        }
        .prose code {
            background-color: #f3f4f6;
            padding: 0.2em 0.4em;
            border-radius: 0.25em;
            font-size: 0.875em;
        }
        .prose pre {
            background-color: #f3f4f6;
            padding: 1em;
            border-radius: 0.5em;
            overflow-x: auto;
            margin: 1em 0;
        }
        .prose ul, .prose ol {
            margin-left: 2em;
            margin-top: 1em;
            margin-bottom: 1em;
        }
        .prose li {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-4">
        <!-- Crawling Section -->
        <div class="bg-white rounded-lg shadow p-6 mb-6">
            <h1 class="text-2xl font-bold mb-4">Web Crawler</h1>
            
            <!-- URL Input -->
            <div class="flex gap-4 mb-4">
                <input type="url" id="url" placeholder="Enter URL to crawl" 
                       class="flex-1 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button onclick="startCrawl()" 
                        class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600">
                    Crawl
                </button>
                <button onclick="stopCrawl()" 
                        class="bg-red-500 text-white px-6 py-2 rounded hover:bg-red-600">
                    Stop
                </button>
            </div>
            
            <!-- Console Output -->
            <div id="output" class="bg-black text-green-400 p-4 rounded font-mono text-sm whitespace-pre-wrap h-64 overflow-y-auto"></div>
        </div>

        <!-- Files and Preview Section -->
        <div class="grid grid-cols-2 gap-4 mt-4">
            <!-- File List -->
            <div>
                <h2 class="text-xl font-bold mb-4">Files</h2>
                <div id="file-list" class="bg-white rounded-lg shadow overflow-y-auto max-h-[600px]">
                    <!-- Files will be listed here -->
                </div>
            </div>

            <!-- Preview Section -->
            <div>
                <h2 class="text-xl font-bold mb-4">Preview</h2>
                <div id="preview" class="bg-white rounded-lg shadow p-4 prose max-w-none overflow-y-auto max-h-[600px]">
                    <!-- Preview content will be shown here -->
                </div>
            </div>
        </div>

        <!-- File Actions Bar -->
        <div id="fileActions" class="file-actions">
            <button onclick="createZip()" class="bg-blue-500 text-white px-6 py-2 rounded-lg hover:bg-blue-600">
                Download Selected
            </button>
            <button onclick="deleteSelected()" class="bg-red-500 text-white px-6 py-2 rounded-lg hover:bg-red-600">
                Delete Selected
            </button>
            <span id="selectedCount" class="text-gray-600 font-semibold"></span>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.0/marked.min.js"></script>
    <script>
        const selectedFiles = new Set();
        let currentCrawlSession = null;
        let currentSessionId = null;
        let statusCheckInterval = null;
        let currentViewMode = 'rendered'; // or 'raw'
        
        marked.setOptions({
            breaks: true,
            gfm: true,
            sanitize: false
        });
        
        let isUserScrolling = false;
        let lastScrollTop = 0;
        let autoScroll = true;

        // Terminal auto-scroll handling
        const terminal = document.getElementById('output');
        
        terminal.addEventListener('scroll', function() {
            // Detect if user is scrolling up
            if (terminal.scrollTop < lastScrollTop) {
                autoScroll = false;
            }
            
            // If user scrolls to bottom, re-enable auto-scroll
            if (terminal.scrollHeight - terminal.scrollTop === terminal.clientHeight) {
                autoScroll = true;
            }
            
            lastScrollTop = terminal.scrollTop;
        });

        function updateTerminal(text) {
            terminal.textContent = text;
            if (autoScroll) {
                terminal.scrollTop = terminal.scrollHeight;
            }
        }

        async function startCrawl() {
            const url = document.getElementById('url').value.trim();
            const output = document.getElementById('output');
            
            if (!url) {
                alert('Please enter a URL');
                return;
            }
            
            try {
                const response = await fetch('/api/crawl', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                currentCrawlSession = data.sessionId;
                output.textContent = 'Crawl started...\n';
                
                // Start polling for status
                pollCrawlStatus();
            } catch (error) {
                console.error('Error starting crawl:', error);
                output.textContent += `Error: ${error.message}\n`;
            }
        }
        
        async function stopCrawl() {
            if (!currentCrawlSession) {
                return;
            }
            
            try {
                const response = await fetch(`/api/crawl/stop/${currentCrawlSession}`, {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('output').textContent += 'Crawl stopped.\n';
                }
            } catch (error) {
                console.error('Error stopping crawl:', error);
            }
        }
        
        async function pollCrawlStatus() {
            if (!currentCrawlSession) {
                return;
            }
            
            try {
                const response = await fetch(`/api/crawl/status/${currentCrawlSession}`);
                const data = await response.json();
                
                if (data.output) {
                    updateTerminal(data.output);
                }
                
                if (data.error) {
                    updateTerminal(terminal.textContent + '\nError: ' + data.error);
                }
                
                if (data.status === 'completed') {
                    currentCrawlSession = null;
                    updateFileList();
                } else if (data.status !== 'not_found') {
                    setTimeout(pollCrawlStatus, 1000);
                }
            } catch (error) {
                console.error('Error polling status:', error);
            }
        }
        
        async function updateFileList() {
            const fileList = document.getElementById('file-list');
            
            try {
                const response = await fetch('/api/files');
                const files = await response.json();
                
                if (!Array.isArray(files)) {
                    throw new Error('Expected array of files');
                }
                
                if (files.length === 0) {
                    fileList.innerHTML = '<div class="p-4 text-gray-500">No files found</div>';
                    return;
                }
                
                // Group files by domain
                const filesByDomain = {};
                files.forEach(file => {
                    if (!filesByDomain[file.domain]) {
                        filesByDomain[file.domain] = [];
                    }
                    filesByDomain[file.domain].push(file);
                });
                
                let html = '';
                
                // Display files grouped by domain
                for (const [domain, domainFiles] of Object.entries(filesByDomain)) {
                    // Format domain name nicely
                    const domainDisplay = domain === 'root' ? 'Files' : domain;
                    
                    html += `
                        <div class="p-4 bg-white rounded-lg shadow mb-4">
                            <h3 class="text-lg font-semibold mb-3 text-gray-700">
                                ${domainDisplay}
                            </h3>
                            <div class="space-y-2">
                    `;
                    
                    for (const file of domainFiles) {
                        html += `
                            <div class="file-item flex items-center space-x-2 p-2 rounded hover:bg-gray-50">
                                <input type="checkbox" 
                                       class="form-checkbox h-4 w-4 text-blue-500"
                                       onchange="toggleFileSelection(this, '${file.path}')"
                                       ${selectedFiles.has(file.path) ? 'checked' : ''}>
                                <a href="#" 
                                   onclick="event.preventDefault(); viewFile('${file.path}')"
                                   class="flex-grow text-blue-600 hover:underline">
                                    ${file.displayName}
                                </a>
                                <a href="/api/download/${encodeURIComponent(file.path)}" 
                                   class="text-gray-500 hover:text-gray-700"
                                   download>
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                                    </svg>
                                </a>
                            </div>
                        `;
                    }
                    
                    html += `
                            </div>
                        </div>
                    `;
                }
                
                fileList.innerHTML = html;
                updateFileActions();
            } catch (error) {
                console.error('Error loading files:', error);
                fileList.innerHTML = '<div class="p-4 text-red-500">Error loading files: ' + error.message + '</div>';
            }
        }
        
        async function viewFile(filePath) {
            try {
                const response = await fetch(`/api/view/${encodeURIComponent(filePath)}`);
                const data = await response.json();
                
                if (data.content) {
                    // Convert markdown to HTML
                    const htmlContent = marked.parse(data.content);
                    document.getElementById('preview').innerHTML = htmlContent;
                    
                    // Highlight the selected file
                    const fileItems = document.querySelectorAll('.file-item');
                    fileItems.forEach(item => {
                        item.classList.remove('bg-blue-50');
                    });
                    const selectedItem = document.querySelector(`[onclick*="${filePath}"]`).parentElement;
                    selectedItem.classList.add('bg-blue-50');
                } else {
                    document.getElementById('preview').innerHTML = '<p class="text-gray-500">No content available</p>';
                }
            } catch (error) {
                console.error('Error viewing file:', error);
                document.getElementById('preview').innerHTML = '<p class="text-red-500">Error loading file content</p>';
            }
        }
        
        function toggleFileSelection(checkbox, filePath) {
            if (checkbox.checked) {
                selectedFiles.add(filePath);
            } else {
                selectedFiles.delete(filePath);
            }
            updateFileActions();
        }
        
        function updateFileActions() {
            const actions = document.getElementById('fileActions');
            if (actions) {
                actions.style.display = selectedFiles.size > 0 ? 'flex' : 'none';
            }
        }
        
        async function createZip() {
            if (selectedFiles.size === 0) {
                alert('Please select files to download');
                return;
            }

            try {
                const response = await fetch('/api/create-zip', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        files: Array.from(selectedFiles)
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Create a download link
                    const downloadUrl = `/api/download-zip/${encodeURIComponent(data.filename)}`;
                    window.location.href = downloadUrl;
                    
                    // Clear selection after successful download
                    selectedFiles.clear();
                    updateFileActions();
                } else {
                    throw new Error(data.error || 'Failed to create zip file');
                }
            } catch (error) {
                console.error('Error creating zip:', error);
                alert('Error creating zip file: ' + error.message);
            }
        }
        
        async function deleteSelected() {
            if (selectedFiles.size === 0) return;
            
            if (!confirm(`Are you sure you want to delete ${selectedFiles.size} file(s)?`)) {
                return;
            }
            
            try {
                const filesToDelete = Array.from(selectedFiles);
                console.log('Deleting files:', filesToDelete);
                
                const response = await fetch('/api/files', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ files: filesToDelete })
                });
                
                const data = await response.json();
                console.log('Delete response:', data);
                
                if (data.success && data.success.length > 0) {
                    alert(`Successfully deleted ${data.success.length} file(s)`);
                    selectedFiles.clear();
                    updateFileActions();
                    updateFileList();
                }
                
                if (data.failed && data.failed.length > 0) {
                    const failedFiles = data.failed.map(f => f.file).join(', ');
                    alert(`Failed to delete: ${failedFiles}`);
                }
            } catch (error) {
                console.error('Error deleting files:', error);
                alert('Error deleting files');
            }
        }
        
        // Initial file list load
        updateFileList();
    </script>
</body>
</html>
